[
  {
    "id": "1",
    "titre": "Mini-jeux en React",
    "mots_cles": ["React", "JsonServer"],
    "description_breve": "Ma première application en React, avec formulaire de connexion et base de donnée json server",
    "miniature": "/Project/miniature_react_firstapp.webp",
    "images": ["/Project/react_firstapp_game.webp", "/Project/react_firstapp_login.webp", "/Project/react_firstapp_top.webp"],
    "informations": "J'ai mis en place deux petits jeux dont les règles sont très simples. Il existe une interface de connexion qui permet d'accéder au jeu si l'utilisateur est identifié, sinon une notification apparaît pour lui proposer de s'inscrire. Il existe un classement des 10 joueurs les plus victorieux, ainsi qu'une option pour se déconnecter. J'ai utilisé JsonServer en tant que base de données.",
    "equipe": "1",
    "date": "03-2023"
  },
  {
    "id": "2",
    "titre": "Éditeur de labyrinthe",
    "mots_cles": ["Android", "Java"],
    "description_breve": "Application qui permet de créer et éditer des labyrinthes au format json.",
    "miniature": "/Project/miniature_labrynth_editor.webp",
    "images": ["/Project/labyrinthe_home.webp", "/Project/labyrinthe_new.webp", "/Project/labyrinthe_liste.webp", "/Project/labyrinthe_view.webp", "/Project/labyrinthe_edit_mode.webp"],
    "informations": "Cette application mobile, développée en Java pour Android, permet de récupérer des labyrinthes hébergés sur un serveur distant, d’accéder à ceux stockés localement ou d’en créer de nouveaux. L’édition est possible en ajoutant des entrées, des sorties et en modifiant la structure du labyrinthe. Dans le fichier JSON, seules les coordonnées des chemins, des points d’arrivée et des salles sont enregistrées ; tout ce qui n’est pas spécifié est considéré comme un mur. Chaque type de case (chemin, salle, point d’arrivée, mur) est associé à une texture spécifique.",
    "equipe": "2",
    "date": "02-2024"
  },
  {
    "id": "3",
    "titre": "Pacman 3D",
    "mots_cles": ["C#", "Unity"],
    "description_breve": "Découverte d'Unity en réalisant un jeu de Pacman en 3D.",
    "miniature": "/Project/miniature_pacman3d.webp",
    "images": ["/Project/pacman1.webp", "/Project/pacman2.webp", "/Project/pacman3.webp"],
    "informations": "Ce projet d’une semaine m’a permis de découvrir les bases d’Unity. Chaque niveau est chargé à partir d’un labyrinthe au format JSON, puis modélisé en 3D. Des fantômes mortels se déplacent dans celui-ci, et nous pouvons contrôler Pac-Man avec les touches \"ZQSD\". Pour gagner, il faut trouver la sortie ou récupérer toutes les pièces sans mourir.",
    "equipe": "1",
    "date": "01-2024"
  },
  {
    "id": "4",
    "titre": "Théorie de l'information, wordgame et entropie",
    "mots_cles": ["Python", "Math"],
    "description_breve": "Rapport sur les applications de la théorie de l'information de Claude E. Shannon",
    "miniature": "/Project/miniature_theorie_info.webp",
    "images": [],
    "informations": "Mise en application de concepts mathématiques dans des problématiques concrètes en informatique. En plus de la rédaction de ce rapport, nous avons réalisé en Python plusieurs algorithmes, tels que : \n \n - La compression de données de Huffman, \n \n - Les codes correcteurs d’erreurs de Hamming, \n \n - Le chiffrement affine, \n \n - Le protocole d’échange de clés de Diffie-Hellman. \n \nNous avons également développé un Wordle (semblable au jeu Motus) en Python, ainsi qu’un algorithme permettant de le résoudre en un minimum de coups grâce à la notion d’entropie.",
    "equipe": "2",
    "date": "05-2024",
    "fichiers": ["/Project/Theorie_information.pdf"]
  },
  {
    "id": "5",
    "titre": "Ordinat'R",
    "mots_cles": ["C#", "Windows Form", "SQL", "Python"],
    "description_breve": "Application de visualisation des émissions de CO2 par pays en lien avec les déchets électroniques.",
    "miniature": "/Project/miniature_ordinatr.webp",
    "images": ["/Project/ordinat_r_schema.webp", "/Project/ordinat_r_gantt.webp"],
    "informations": "Ce logiciel d’aide à la décision a été développé en C# pour l’interface graphique. Il utilise également Python pour la partie calculatoire et SQL pour la gestion de la base de données. En s’appuyant sur des indicateurs statistiques tels que la moyenne ou les droites de régression, ce logiciel permet de comparer divers facteurs, comme les émissions de CO₂ ou le volume de déchets par pays. Nous avons également créé un installateur en Bash permettant de déployer automatiquement la base de données et de la remplir. Nous avons réalisé ce projet en deux semaines, en respectant une méthodologie de type cycle en V. Je me suis occupé, avec l’aide d’un camarade, de la gestion de projet en plus du développement.",
    "equipe": "5",
    "date": "06-2023"
  },
  {
    "id": "6",
    "titre": "CV vidéo",
    "mots_cles": ["CV", "Vidéo", "Communication"],
    "description_breve": "Un CV vidéo pour une recherche de stage, inspiré de la série Bref",
    "miniature": "/Project/miniature_cvvideo.webp",
    "images": [],
    "informations": "CV vidéo que j'ai réalisé dans le cadre du cours de communication et de ma recherche de stage. Inspiré de la websérie Bref de Kyan Khojandi. Je remercie Aurore Menn pour son aide durant le tournage et Maxence Mingasson pour ses talents de monteur.",
    "equipe": "3",
    "date": "11-2024",
    "fichiers": ["https://youtu.be/b_JZDxGoxvg"]
  },
  {
    "id": "7",
    "titre": "Reconnaissance de chiffres manuscrits",
    "mots_cles": ["Python"],
    "description_breve": "Introduction à l'apprentissage supervisé et au traitement d'images",
    "miniature": "/Project/miniature_apprentissage_supervise.webp",
    "images": [],
    "informations": "Dans ce projet, j'ai développé un système de reconnaissance de chiffres manuscrits basé sur l'algorithme des k-plus proches voisins (k-NN). L'objectif est d'identifier un chiffre manuscrit à partir d'images issues du dataset MNIST (https://en.wikipedia.org/wiki/MNIST_database).\n\n Méthode:\n\n - Prétraitement des images : redimensionnement, conversion en niveaux de gris, binarisation, érosion et dilatation pour réduire le bruit \n - Extraction de caractéristiques (Zoning) : division de l’image en 25 blocs, puis comptage du nombre de pixel noir \n - Classification avec k-NN : calcul des distances entre les vecteurs de caractéristiques de mes images et ceux de la base d’apprentissage pour k=3. Ensuite on attribue le label majoritaire parmi les plus proches voisins.\n\nLe modèle atteint un taux de reconnaissance de 91%, avec des confusions observées notamment entre certains chiffres visuellement proches (1/7, 8/9).",
    "equipe": "1",
    "date": "10-2024",
    "fichiers": ["/Project/Rapport_analyse_image_LASSERRE_Joris.pdf"]
  },
  {
    "id": "8",
    "titre": "Pandemic",
    "mots_cles": ["Python", "Kivy", "OracleDB"],
    "description_breve": "Implémentation du jeu de société Pandemic sous forme d'application python avec base de données.",
    "miniature": "/Project/miniature_pandemic.webp",
    "images": [],
    "informations": "Nous avons eu 2 semaines et l'obligation d'utiliser la méthode scrum pour réaliser ce projet. Les sprints étaient de 3 jours et un enseignant jouait le rôle du client, devant lequel on faisait notre démo. Pour le côté technique nous avons utilisé python, le framework Kivy pour le front et OracleDB pour la base de données. Je me suis principalement occupé d'implémenter les règles côté backend et de m'assurer que la mise en place de la méthode scrum était respectée (Backlog, Plannification, Sprint, démo).",
    "equipe": "7",
    "date": "09-2024"
  },
  {
    "id": "9",
    "titre": "Guiblix",
    "mots_cles": ["Symfony", "SQL", "Html", "Css", "Js"],
    "description_breve": "Site inspiré d'IMDb dans lequel les utilisateurs peuvent noter et commenter des films.",
    "miniature": "/Project/miniature_guiblix.webp",
    "images": ["/Project/guiblix_home.webp", "/Project/guiblix_register.webp", "/Project/guiblix_series.webp"],
    "informations": "Ce projet a consisté à créer une plateforme inspirée d'IMDb, dédiée aux séries télévisées, permettant aux utilisateurs de noter, commenter, liker et marquer leurs séries comme vues. Le contenu est enrichi grâce à l'API IMDb, offrant un large catalogue de séries. \n\nLes fonctionnalités incluent :\n\n - Inscription et connexion des utilisateurs pour un accès sécurisé aux fonctionnalités de la plateforme.\n - Interface intuitive permettant de consulter des séries, de les noter, de laisser des critiques et d’interagir avec d’autres utilisateurs.\n - Gestion d’un tableau de bord personnel pour suivre les séries vues et préférées.\n - Recherche avancée pour explorer des séries par genre, note, ou année de sortie.\n\nRéalisé par une équipe de 6 personnes en 2 semaines, le développement a été structuré avec Symfony pour le backend, SQL pour la gestion des données, et HTML/CSS/JS pour l’interface frontend. La méthode Scrum a été utilisée pour une gestion agile et efficace du projet.",
    "equipe": "6",
    "date": "01-2024"
  },
  {
    "id": "10",
    "titre": "Pokedex 3D",
    "mots_cles": ["React", "Express", "Tailwind", "MongoDB"],
    "description_breve": "Site affichant des informations sur les 151 premiers pokemons ainsi que leur modèle 3D.",
    "miniature": "/Project/miniature_pokedex3d.webp",
    "images": ["/Project/pokedex_displayPokemon.webp", "/Project/pokedex_allPokemons.webp", "/Project/pokedex_teamType.webp", "/Project/pokedex_signup_in.webp", "/Project/pokedex_adminPage.webp", "/Project/pokedex_filter.webp", "/Project/pokedex_searchBar.webp"],
    "informations": "Nous avons eu une semaine pour réaliser ce site en méthode Agile. Nous avons utilisé React pour le front, Express pour le back et MongoDB pour la base de données. Je me suis principalement occupé des deux cadres (statistiques et informations) sur la page de visualisation d’un Pokémon, de la modification des données sur la page admin, ainsi que de la mise en place de la majeure partie des endpoints de l’API.",
    "equipe": "5",
    "date": "12-2024"
  },
  {
    "id": "11",
    "titre": "PoC Crous Bordeaux",
    "mots_cles": ["Symfony", "Tailwind", "Python", "MariaDB"],
    "description_breve": "Proof Of Concept d'un outil de suivi des biodéchets pour le Crous de Bordeaux.",
    "miniature": "/Project/miniature_poc_crous_bordeaux.webp",
    "images": ["/Project/crous_accueil.webp", "/Project/crous_connexion.webp", "/Project/crous_graphe.webp", "/Project/crous_incident.webp", "/Project/crous_panelAdmin.webp"],
    "informations": "Dans le cadre de ma formation, j’ai participé à un projet innovant de deux semaines en collaboration avec un véritable client : le Crous de Bordeaux. L’objectif était de répondre à une problématique concrète rencontrée par les restaurants universitaires : réduire le gaspillage.\n\nLes prestataires chargés de la collecte des déchets fournissaient des rapports indiquant le poids des déchets, mais chacun utilisait un format différent. Le Crous devait alors traiter ces données avec d’anciens tableaux Excel, rendant l’analyse complexe et limitant l’exploitation des informations.\n\nPour répondre à ce besoin, nous avons conçu et développé un site web permettant de centraliser, unifier et valoriser ces données. Parmi les fonctionnalités clés, notre solution propose :\n\n - Une carte interactive des restaurants universitaires\n - Une comparaison des données hebdomadaires (semaine en cours vs. semaine précédente)\n - La possibilité de signaler des incidents\n - L’affichage d’alertes en cas de valeurs aberrantes\n - L’automatisation du scraping et de la récupération des données. \n\nCôté stack technologique, nous avons opté pour Symfony (+bundle EasyAdmin) avec MariaDB pour le backend, Tailwind CSS pour le frontend, et Python (BeautifulSoup, Selenium) pour le scraping des données. L’automatisation repose sur des scripts exécutés via des CRON jobs sur un serveur VPS, où la solution a été déployée.\n\nTout au long du projet, nous avons collaboré étroitement avec le client, affinant les exigences au fil des échanges pour aboutir à un produit fonctionnel et opérationnel.",
    "equipe": "5",
    "date": "01-2025"
  }
  
  
]
